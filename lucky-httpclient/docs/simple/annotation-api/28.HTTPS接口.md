## 🔒 HTTPS

`HTTPS`（Hypertext Transfer Protocol Secure）是 `HTTP`（超文本传输协议）的加密版，它通过 SSL/TLS 协议加密 HTTP
请求和响应，从而确保数据的安全性和完整性。HTTPS 常用于保护网络通信中的敏感数据，如登录凭证、支付信息、私人数据等。

### HTTPS 如何工作

1. **加密通信**  
   HTTPS 使用 `SSL/TLS`（Secure Sockets Layer / Transport Layer Security）协议来加密数据。SSL/TLS
   会在客户端和服务器之间建立一个安全的连接，并确保数据在传输过程中不会被第三方窃取或篡改。

2. **身份验证**  
   在使用 HTTPS 进行通信时，服务器会提供一个 `SSL/TLS` 证书，其中包含了服务器的公钥、证书颁发机构（CA）签名等信息。客户端可以验证该证书，确保与正确的服务器进行通信，防止中间人攻击。

3. **数据完整性**  
   由于数据在传输过程中被加密，即使攻击者成功截获了数据流，也无法修改其中的内容，因为加密后的数据和传输的校验码会确保数据的完整性。

### HTTPS 的工作流程

1. **客户端发起请求**  
   当用户访问一个 HTTPS 网站时，浏览器会发起一个请求，要求建立一个安全连接。

2. **服务器响应并发送证书**  
   服务器会响应请求，并发送包含其公钥的 SSL/TLS 证书。该证书由受信任的证书颁发机构（CA）签名，证明服务器的身份。

3. **验证证书**  
   客户端浏览器会验证该证书，确保证书的有效性和服务器的身份。如果证书无效或过期，浏览器会警告用户。

4. **密钥交换**  
   如果证书有效，客户端和服务器将通过一个密钥交换算法（如 Diffie-Hellman 或 RSA）来建立一个对称加密密钥，用于后续通信的数据加密。

5. **加密通信**  
   在建立加密连接后，所有通过 HTTPS 发送的数据都将使用对称加密方式加密，确保通信的隐私性和安全性。

6. **数据传输与验证**  
   数据在传输过程中会进行加密和完整性验证。即使数据被拦截，也无法解密或篡改。

### HTTPS 的主要优点

1. **数据加密**  
   HTTPS 能够加密数据，保护用户的信息免受窃听。尤其在传输敏感信息（如密码、银行卡号）时至关重要。

2. **身份验证**  
   通过 SSL/TLS 证书，用户可以确认网站的身份，防止遭遇钓鱼网站或中间人攻击。

3. **数据完整性**  
   确保数据在传输过程中没有被篡改。如果数据被修改，接收方将能够检测到这一点。

4. **提高 `SEO` 排名**  
   搜索引擎（如 Google）对 HTTPS 网站优先排名，因此使用 HTTPS 可以提高网站的搜索排名。

5. **用户信任**  
   使用 HTTPS 的网站地址栏会显示一个小锁图标，这可以增加用户的信任感，尤其是对于电商网站和社交平台。

### HTTPS 与 HTTP 的区别

| 特性	   | HTTP	         | HTTPS                  |
|-------|---------------|------------------------|
| 安全性   | 不加密，易被窃听和篡改	  | 加密，防止数据窃听和篡改           |
| 端口	   | 默认端口 80	      | 默认端口 443               |
| 协议	   | 无加密的 HTTP 协议	 | 基于 SSL/TLS 加密的 HTTP 协议 |
| 性能	   | 快速，但不安全	      | 由于加密，稍慢于 HTTP          |
| 证书	   | 不需要证书	        | 需要有效的 SSL/TLS 证书       |
| 浏览器标识 | 	无特别标识	       | 地址栏显示小锁标识              |

### 如何使用 HTTPS
1. **申请 SSL/TLS 证书**  
网站需要从受信任的证书颁发机构（CA）申请 SSL/TLS 证书。常见的证书颁发机构有 Symantec、Let's Encrypt（免费的 SSL
证书）、Comodo、GlobalSign 等。

2. **配置 Web 服务器**  
一旦获得证书，网站管理员需要将证书安装到服务器上，并配置服务器（如 Apache、Nginx）支持 HTTPS。通常这会涉及到安装证书和私钥、配置端口
443 等。

3. **重定向 HTTP 到 HTTPS**  
为了强制用户访问 HTTPS，通常需要将 HTTP 请求重定向到 HTTPS。可以通过 Web 服务器配置或在 HTML 中使用 <meta> 标签来实现。

4. **检查证书有效性**  
定期检查证书的有效性，并及时更新到期的证书，避免访问出现安全警告。

---

### # 单向认证

HTTPS 单向认证（One-way SSL/TLS Authentication）是指客户端验证服务器的身份，而服务器不验证客户端的身份。具体来说，HTTPS 协议中的 SSL/TLS 协议通过数字证书来确保通信的安全性。在单向认证中，客户端会通过服务器的公钥证书来验证服务器的身份，确保服务器是合法的，通信过程中的数据不会被篡改或窃取。

#### 单向认证的工作原理：
1. **客户端发起请求**：客户端向服务器发起 HTTPS 请求。
2. **服务器响应并发送证书**：服务器返回一个数字证书，其中包含公钥和服务器的身份信息。
3. **客户端验证证书**：客户端检查服务器证书是否由受信任的证书颁发机构（CA）签发，以及证书是否有效。
4. **生成会话密钥**：客户端使用服务器的公钥加密生成一个共享的会话密钥，并发送给服务器。
5. **加密通信**：客户端和服务器使用会话密钥进行加密通信，确保通信的机密性和完整性。
#### 单向认证的特点：
- **只验证服务器**：客户端验证服务器的身份，但服务器不验证客户端的身份。适用于大多数互联网应用，尤其是浏览器与网站之间的通信。
- **通信加密**：即使没有客户端身份认证，通信内容也会被加密，防止中间人攻击和数据窃听。

### # 代码实现
1. #### 受信任的RootCA机构证书
如果目标站点的SSL证书是由受信任的RootCA机构发布的，无需做任何事情便可以自动信任，例如（google、baidu、github）

```java
public interface GitHubApi {

   @Get("https://www.github.com")
   String index();
}
```

2. #### 信任所有服务器证书
在HTTPS接口上加上`@SSL`注解既可以实现信任所有服务器证书的功能

```java
public interface SSLApi {

   /*
     信任所有服务器证书，使用TLS协议   
    */
   @SSL
   @Get("https://localhost:8864/ssl/test1")
   String sslTest();


   /*
    信任所有服务器证书，使用SSL协议   
  */
   @SSL(protocol = "SSL")
   @Get("https://localhost:8864/ssl/test1")
   String sslTest();
}
```

3. #### 需要校验服务器证书
如果需要严格校验服务器的证书，则可以借助`@SSL`注解的`trustStore`属性来配置信任的证书信息  
该属性支持SpEL表达式，支持`String`和`com.luckyframework.httpclient.core.ssl.KeyStoreInfo`两种类型的返回值类型  
`String`: 从全局的`KeyStore`库中取对应名称的`KeyStore`  
`KeyStoreInfo`: 直接配置`KeyStore`相关的信息

**配置全局`KeyStore`**

- 原生Java环境

```java
public void initKeyStores() {
   HttpClientProxyObjectFactory factory = new HttpClientProxyObjectFactory();
   
   // KeyStore-1
   KeyStoreInfo s1 = new KeyStoreInfo();
   // keystore类型
   s1.setKeyStoreType("PKCS12");
   // keystore秘钥
   s1.setCertPassword("ClientKeyStore@2024");
   // cert秘钥
   s1.setKeyStorePassword("ClientKeyStore@2024");
   // 公钥文件地址
   s1.setKeyStoreFile("classpath:ssl/client.p12");
   
   factory.addKeyStoreInfo("test", s1);
}
```

- SpringBoot环境
```yaml
lucky:
  http-client:
    ssl:
      key-stores:
        - id: test
          # keystore类型
          key-store-type: PKCS12
          # keystore秘钥
          key-store-password: ClientKeyStore@2024
          # cert秘钥
          cert-password: ClientKeyStore@2024
          # 公钥文件地址
          key-store-file: classpath:ssl/client.p12
        - id: test1
          key-store-type: PKCS12
          key-store-password: ServerKeyStore@2024
          key-store-file: classpath:ssl/server.p12
        - id: test2
          key-store-type: JKS
          key-store-password: TrustStore@2024
          key-store-file: classpath:ssl/truststore.jks
```
**指定使用的`KeyStore`**

```java
public interface SSLApi {

   /*
     使用名称为'test'的KeyStore信息来验证服务器证书
    */
   @SSL(trustStore = "test")
   @Get("https://localhost:8864/ssl/test1")
   String sslTest();


   /*
    使用当前对象的trustStore()方法来获取KeyStore信息来验证服务器证书
  */
   @SSL(trustStore = "#{$this$.keyStore()}")
   @Get("https://localhost:8864/ssl/test1")
   String sslTest();

   default KeyStoreInfo trustStore() {
      // KeyStore-1
      KeyStoreInfo s1 = new KeyStoreInfo();
      // keystore类型
      s1.setKeyStoreType("PKCS12");
      // keystore秘钥
      s1.setCertPassword("ClientKeyStore@2024");
      // cert秘钥
      s1.setKeyStorePassword("ClientKeyStore@2024");
      // 公钥文件地址
      s1.setKeyStoreFile("classpath:ssl/client.p12");
      return s1;
   }
}
```

### # 简单双向认证

HTTPS 简单双向认证（Two-way SSL/TLS Authentication）是指在 HTTPS 协议中，不仅服务器通过证书验证客户端身份，客户端也需要通过证书验证服务器身份。这种认证方式提高了双方的信任度和安全性，特别适用于对安全性要求极高的应用场景，比如银行交易、企业内部系统、或者某些敏感信息的交换。

**简单双向认证的工作原理：**  
在传统的单向认证中，只有服务器需要通过证书来验证身份；而在双向认证中，`客户端和服务器都需要相互验证对方的证书`，从而建立双方的信任。

1. **服务器验证客户端身份：**

   - **服务器端**首先会向客户端发送一个自己的 SSL/TLS 证书，证明自己的身份（如网站的域名、证书签发机构等）。
      客户端会检查服务器证书的有效性，比如证书是否过期、是否被信任的证书颁发机构（CA）签发等。如果验证通过，则继续进行加密通信。
2. **客户端验证服务器身份：**

   - **客户端**通过检查服务器证书的签发者、域名等信息，确认自己连接的是正确的服务器。
3. **客户端发送证书：**

   - **客户端**也会提供自己的 SSL/TLS 证书给服务器，以证明自己的身份。这通常用于需要验证客户端身份的场景，如金融应用、企业内网等。
   - **服务器**收到客户端的证书后，会验证客户端的证书是否由信任的证书颁发机构（CA）签发，并检查证书的有效性。
4. 建立加密通道：

   - 在客户端和服务器成功互相验证对方身份后，双方将通过协商生成一个会话密钥，使用对称加密算法对通信进行加密。
   
**双向认证的具体流程：**  

1. **客户端发起连接**：客户端通过 HTTPS 向服务器发起连接请求。  
2. **服务器发送证书**：服务器返回自己的公钥证书，客户端对其进行验证。
3. **客户端发送证书**：如果服务器要求，客户端也会发送自己的证书给服务器。服务器验证客户端证书的有效性。
4. **验证通过后，建立安全通道**：一旦双方的证书验证成功，SSL/TLS 握手完成，双方可以开始安全加密通信。

#### # 代码实现
客户端向服务器提供证书可以通过`@SSL`注解的`keyStore`属性来实现，该属性用于指定提供给服务器证书的KeyStore，具体用法和`trustStore`类似，不再赘述！

```java
public interface SSLApi {

   /*
     1.使用名称为'test1'的keyStore向服务器发送证书
     2.使用名称为'test'的KeyStore信息来验证服务器证书
    */
   @SSL(keyStore = "test1", trustStore = "test")
   @Get("https://localhost:8864/ssl/test2")
   String sslTest();


   /*
    1.使用当前对象的keyStore()方法来获取KeyStore信息用于向服务器提供证书
    2.使用当前对象的trustStore()方法来获取KeyStore信息来验证服务器证书
  */
   @SSL(keyStore = "#{$this$.keyStore()}", trustStore = "#{$this$.trustStore()}")
   @Get("https://localhost:8864/ssl/test2")
   String sslTest2();

   default KeyStoreInfo keyStore() {
      // KeyStore-1
      KeyStoreInfo s1 = new KeyStoreInfo();
      // keystore类型
      s1.setKeyStoreType("PKCS12");
      // cert秘钥
      s1.setKeyStorePassword("ServerKeyStore@2024");
      // 公钥文件地址
      s1.setKeyStoreFile("classpath:ssl/server.p12");
      return s1;

   }

   default KeyStoreInfo trustStore() {
      // KeyStore-2
      KeyStoreInfo s1 = new KeyStoreInfo();
      // keystore类型
      s1.setKeyStoreType("PKCS12");
      // keystore秘钥
      s1.setCertPassword("ClientKeyStore@2024");
      // cert秘钥
      s1.setKeyStorePassword("ClientKeyStore@2024");
      // 公钥文件地址
      s1.setKeyStoreFile("classpath:ssl/client.p12");
      return s1;
   }
}
```

### #自定义SSL验证
更加复杂的SSL验证可以通过`Java`原生的`SSLSocketFactory`和`HostnameVerifier`来实现。

1. 使用`@SSL`注解的`hostnameVerifier`属性和`sslSocketFactory`来指定，这两个属性均支持SpEL表达式，可以使用表达式来获取具体的`SSLSocketFactory`和`HostnameVerifier`实现类

```java

public interface SSLApi {
    
   @SSL(hostnameVerifier = "#{$this$.myHostnameVerifier()}", sslSocketFactory = "#{$this$.mySSLSocketFactory()}")
   @Get("https://localhost:8864/ssl/test3")
   String sslTest3();
   
   // 自定义HostnameVerifier
   default HostnameVerifier myHostnameVerifier() {
      // 省略具体实现代码 
   }

   // 自定义SSLSocketFactory
   default SSLSocketFactory mySSLSocketFactory() {
       // 省略具体实现代码
   }
}
```

2. 使用`@SSLMeta`通过`SSLSocketFactoryBuilder`和`HostnameVerifierBuilder`来获取`SSLSocketFactory`和`HostnameVerifier`

- 定义`HostnameVerifierBuilder`
```java
public class MyHostnameVerifierBuilder implements HostnameVerifierBuilder {
   
    // 获取HostnameVerifier
   public HostnameVerifier getHostnameVerifier(SSLAnnotationContext sslAnnContext) {
      // 省略具体实现代码
   }
}
```

- 定义`SSLSocketFactoryBuilder`
```java
public class MySSLSocketFactoryBuilder implements SSLSocketFactoryBuilder {
   
   // 获取SSLSocketFactory
   public SSLSocketFactory getSSLSocketFactory(SSLAnnotationContext sslAnnContext) {
      // 省略具体实现代码
   }

}

```

- 应用
```java
public interface SSLApi {
    
    @SSLMeta(
         hostnameVerifierBuilder = @ObjectGenerate(MyHostnameVerifierBuilder.class),
         sslSocketFactoryBuilder = @ObjectGenerate(MySSLSocketFactoryBuilder.class)  
    )
   @Get("https://localhost:8864/ssl/test4")
   String sslTest4();
}
```